Вы должны понимать что потоки когда программа создает потоки,
он обращается к .Net а он к OS.

Допустим у вас 5 потоков которые будут делать одну и ту же задачу

И вот `Lock` не пускает сразу 5 потоков что бы они выполняли, 
он берет поток и с помощью bool переменной он закрывает задачу, пока задача не будет выполненна.
Так вот Lock не говорит что он работает по одному с потоками, он говорит что 
он работает со всеми потоками, то есть он работает с 5 потокаим.

`Lock` знает только о существовании .Net

### Правило 40 секунд

Если поток ничем не занят 40 сек, он должен быть возвращен.

Если OS галадает, то он заберет патоки, не смотря на то что ваша программа
использует поток.

----------------------------------------------------------------

Если все работает слишком быстро, то возможно что последовательность нарушится.


`Mutex`
Он не скрывает работу, он говорит что я работаю с одним потоком, сообщает 
OS с кем он работает и OS знает какой поток пуст, а какой нет.

`Lock` работает на уровне .NET 
а `Mutex` и `Semaphore` на уровне OS 

`Для чего мы управляем потоками?`

в 99% мы ими не управляем, но иногда нам нужно вручную их создавать.
Например если нам нужно что бы прога быстро работала или что-то связанное
с серверами.

В 90% все происходит `Асинхронно`

`Semaphore`

В отличии от `Mutex` принимает два параметра
- Первый `InitialCount`
по дефолту сколько нужно впустить потоков для выполнения задачи
- Второй `MaximumCount` и сколько максимум может впустить.

`Semaphore` - это несколько `Mutex`

Он может впускать сразу несколько потоков.

Допустим параметры стоят (2,3), то он впустит два потока и запустит их одновременно
а 3 поток будет в ожидании.

### Собятия блокировки

- `CountDownEvent`
- `ManualResetEvent`
- `AutoResetEvent`


Это все собятия блокировки, которые блокируют поток.
Потока останавливает свою работу, пока событие не возобновит работу потока.

События не имеют ни какой связи с `Lock`, `Mutex` и тд.

Приве с `CountDownEvent`

``` csharp
class Program
{
    private static CountdownEvent countdownEvent = new(5); 5 - сколько сигналов должно быть что бы поток возобновился

    public static void Sample()
    {
        using Mutex mutex = new();
        mutex.WaitOne();

        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"Hello from: {Thread.CurrentThread.ManagedThreadId}");
        }

        countdownEvent.Signal();

        `Он уменьшает 5 на один, сигнал 
        Сигнал возвращает bool, если он вернул true, то он отнимает от 5 один, а если false
        то Wait() возобновляет свою работу`

        mutex.ReleaseMutex();
    }

    public static void Main(string[] args)
    {
        Console.WriteLine("Main started");

        for (int i = 0; i < 5; i++)
        {
            Thread th1 = new(Sample);
            th1.Start();
        }

        countdownEvent.Wait(); останавливает поток, в данном случаи main поток

        Console.WriteLine("Main finished");
    }
}

```