У каждого потока есть свой стек.
Они не видят друг друга переменные.

``` csharp
class Program
{
    public static void CountToFive()
    {
        for (int i = 0; i < 5; i++)
        {
            Console.WriteLine($"This is {i} from thread: {Thread.CurrentThread.ManagedThreadId}");
        }
    }
    public static void Main(string[] args)
    {
        Console.WriteLine("Main started...");
        for (int i = 0; i < 5; i++)
        {
            Thread th = new(CountToFive);
            Console.WriteLine($"Created thread: {th.ManagedThreadId}");
            th.Start();
        }
    }
}
```

Потоки выполняют работу конкурентно.

Кто успел тот и съел.

Поток создать не возможно, вы поток ставите в очередь.

Проблема в том что они очень быстрые, и если какой то поток
медленее, то его опережают.

# Синхронизация потоков

### есть I/O и CPU bound

`Bound` - ограничение, поток в котором выполняется операция
будет ждать пока вы сделаете ввод или вывод данных.

`I/O` 
Oсновная часть времени исполнения этой задачи тратится на ожидание завершения 
операций ввода-вывода, таких как чтение или запись данных на диск, сетевые операции,
запросы к базе данных и т. д

### CPU

Это операции которые выполняются долго, на уровне процессора.
Крч задача которая занимает много времени, например запрос
в бд который выполняется долго. Например сложные вычеслительные задачи
на уровне процесса

###  Инструменты для синхронизации потоков

## `Lock`

На самом деле это синтаксический сахар для класса `Monitor`

В IL код он выглядит как try-finally, в котором вызывается 
`Monitor.Enter` а в finally вызывается `Monitor.Exit`

не даёт что бы кто-то врывался в твою очередь, но если это
происходит очень быстро, есть вероятность что другие потоки 
ворвутся в его очередь.

Он закрывает поток до момента выполнения задачи, потом открывает поток.
В IL коде он он выгллядит как object и bool переменная.

и если поток долго работает, он может остановить его и дать дорогу
другому потоку.

## Mutex 

Более гибкий инструмент для синхронизации потоков

первый параметр начальное состояние, второй имя.
Первый параметр, то есть он по дефолту к кому то принадлежит или нет,
если там true, кроме одного потока не кто не сможет его взять, 
даже если вы его отпустите.

У `WaitOne` есть перегрузки.
Если вы timeout напишите и если он не успеет, то он дает работу другому
а если и ещё там стоит true, то он больше не когда не сможет вернуться к нему.

Release отпускает поток.

Крч это инструмент который позволяет захватить ресурс и ждать других 
потоков пока поток не выполнит свою работу
